//Spectral match module
//In this module, all the spectral will be matched to reference which includes target-decoy database or target database
//This package also includes some data struct generated by XY-Meta during spectrum matching
package match

import (
	"dataframe"
	"fmt"
	"math"
	"plug"
	"ranker"
	"reader"
	"sync"
	"time"
)

var l sync.Mutex

type error_window struct {
	Tolerance   float64
	Window_tyoe int
}

type error_isotope struct {
	Tolerance  float64
	Error_type int
}

type PeakElement struct {
	x       float64
	y       float64
	weights float64
}

type Coordinatelist struct {
	Headcoordinate  PeakElement
	Coordinategroup dataframe.LinkList
}

func Alignment(query_spectral []reader.Spectrum, reference_spectral, Decoy_database []reader.Spectrum, Adduct_isotope_list dataframe.Adduct_isotope, Input_param dataframe.Parameters) ([]dataframe.Grade, []reader.Spectrum) {
	Start := time.Now()
	plug.Spectralclear(query_spectral, Input_param)
	signal_weights := Signal_distribution(query_spectral, reference_spectral)
	reference_spectral = append(reference_spectral, Decoy_database...)
	fmt.Println("Begin To Search!")
	var quick_scanning [][]int
	for i := 0; i < len(query_spectral); i++ {
		var search_storage []int
		quick_scanning = append(quick_scanning, search_storage)
	}
	sc := make(chan int)
	for i := 0; i < Input_param.Threads; i++ {
		go primary_screen(sc, i*len(query_spectral)/Input_param.Threads, (i+1)*len(query_spectral)/Input_param.Threads, query_spectral, reference_spectral, Adduct_isotope_list, Input_param, quick_scanning)
	}
	for i := 0; i < Input_param.Threads; i++ {
		<-sc
	}
	fmt.Println("Search Done!", time.Since(Start))
	fmt.Println("Mapping!")
	var Match_result_list []dataframe.Grade
	c := make(chan int)
	for i := 0; i < Input_param.Threads; i++ {
		go Bombmatch(c, i*len(query_spectral)/Input_param.Threads, (i+1)*len(query_spectral)/Input_param.Threads, query_spectral, reference_spectral, signal_weights, quick_scanning, &Match_result_list, Input_param)
	}
	for i := 0; i < Input_param.Threads; i++ {
		<-c
	}
	fmt.Println("Mapping Done!", time.Since(Start))
	return Match_result_list, reference_spectral
}

func Bombmatch(c chan int, slice_start, slice_end int, query_spectral []reader.Spectrum, reference_spectral []reader.Spectrum, signal_weights [][]float64, quick_scanning [][]int, match_result_list *[]dataframe.Grade, Input_param dataframe.Parameters) {
	for i := slice_start; i < slice_end; i++ {
		Spectral_grade := dataframe.CreateLinkList()
		for j := 0; j < len(quick_scanning[i]); j++ {
			grade_test := Match(signal_weights[i], query_spectral[i], reference_spectral[quick_scanning[i][j]], quick_scanning[i][j], Input_param)
			Spectral_grade.Append(grade_test)
		}
		if Spectral_grade.GetLength() != 0 {
			Top_grade := ranker.Matchrank(Spectral_grade, Input_param.Match_model)
			Top_grade.Queryindex = i
			l.Lock()
			*match_result_list = append(*match_result_list, Top_grade)
			l.Unlock()
		}
	}
	c <- 1
}

func Match(weight_intensity []float64, query_spectrum, reference_spectrum reader.Spectrum, step_index int, Input_param dataframe.Parameters) dataframe.Grade {
	var match_result dataframe.Grade
	if len(query_spectrum.Peaks) == 0 {
		return match_result
	} else {
		match_result.Index = step_index
		query_coordinate_list := dataframe.CreateLinkList()
		var start_match int
		for i := 0; i < len(reference_spectrum.Peaks); i++ {
			if Input_param.Isotope == 0 {
				start_match_temp, Coordinate_group := query_coordinate_Da(start_match, query_spectrum, reference_spectrum.Peaks[i], weight_intensity, Input_param)
				start_match = start_match_temp
				query_coordinate_list.Append(Coordinate_group)
			} else if Input_param.Isotope == 1 {
				start_match_temp, Coordinate_group := query_coordinate_PPm(start_match, query_spectrum, reference_spectrum.Peaks[i], weight_intensity, Input_param)
				start_match = start_match_temp
				query_coordinate_list.Append(Coordinate_group)
			}

		}
		maprate(query_coordinate_list, &match_result)
		noiserate(len(query_spectrum.Peaks), query_coordinate_list, &match_result)
		adotproduct(query_coordinate_list, &match_result, reference_spectrum, Input_param.MMI)
		finalscore(&match_result)
		return match_result
	}
}

func primary_screen(sc chan int, slice_start, slice_end int, query_spectral, reference_spectral []reader.Spectrum, Adduct_isotope_list dataframe.Adduct_isotope, Input_param dataframe.Parameters, search_map [][]int) {
	var tolerance_list []float64
	for i := 0; i < len(Adduct_isotope_list.Isotope_mass_list); i++ {
		tolerance_list = append(tolerance_list, Adduct_isotope_list.Isotope_mass_list[i])
	}
	for i := slice_start; i < slice_end; i++ {
		var compounds_add []float64
		for l := 0; l < len(Adduct_isotope_list.Isotope_mass_list); l++ {
			compounds_add = append(compounds_add, Adduct_isotope_list.Isotope_precusor_nums[l]*query_spectral[i].Precusor_mass-Adduct_isotope_list.Isotope_mass_list[l])
		}
		for j := 0; j < len(reference_spectral); j++ {
			if Input_param.Precur == 0 {
				for l := 0; l < len(compounds_add); l++ {
					tolerance_list[l] = math.Abs(compounds_add[l] - reference_spectral[j].Precusor_mass)
				}
			} else if Input_param.Precur == 1 {
				for l := 0; l < len(compounds_add); l++ {
					tolerance_list[l] = plug.PPm(compounds_add[l], reference_spectral[j].Precusor_mass)
				}
			}
			for l := 0; l < len(tolerance_list); l++ {
				if tolerance_list[l] <= Input_param.Tolerance_precur {
					search_map[i] = append(search_map[i], j)
					break
				}
			}
		}
	}
	sc <- 1
}

func Signal_distribution(query_spectrum, reference_spectral []reader.Spectrum) [][]float64 {
	var signal_group []float64
	for i := 0; i < len(reference_spectral); i++ {
		for j := 0; j < len(reference_spectral[i].Peaks); j++ {
			signal_group = append(signal_group, reference_spectral[i].Peaks[j].Peak_intensity)
		}
	}
	mean := plug.Mean(signal_group)
	SD := plug.Standard_deviation(signal_group)
	var weights_signal [][]float64
	for i := 0; i < len(query_spectrum); i++ {
		var weights []float64
		for j := 0; j < len(query_spectrum[i].Peaks); j++ {
			G_test := 1 / (50 + plug.Grubbs(query_spectrum[i].Peaks[j].Peak_intensity, mean, SD))
			weights = append(weights, G_test)
		}
		weights_signal = append(weights_signal, weights)
	}
	return weights_signal
}

func InialRefrence(reference_spectral []reader.Spectrum) dataframe.LinkList {
	ref_caculation_coordinate := dataframe.CreateLinkList()
	for i := 0; i < len(reference_spectral); i++ {
		spectrum_element := dataframe.CreateLinkList()
		for j := 0; j < len(reference_spectral[i].Peaks); j++ {
			var spectrum_peaks PeakElement
			spectrum_peaks.x, spectrum_peaks.y = 0.0, reference_spectral[i].Peaks[j].Peak_intensity
			spectrum_element.Append(spectrum_peaks)
		}
		ref_caculation_coordinate.Append(spectrum_element)
	}
	return ref_caculation_coordinate
}

func query_coordinate_Da(start_index int, query_spectrum reader.Spectrum, ref_coordinate reader.Signal, weight_intensity []float64, Input_param dataframe.Parameters) (int, *Coordinatelist) {
	var query_coordinate_group Coordinatelist
	query_coordinate_group.Headcoordinate.x, query_coordinate_group.Headcoordinate.y = 0.0, ref_coordinate.Peak_intensity
	for i := start_index; i < len(query_spectrum.Peaks); i++ {
		if query_spectrum.Peaks[i].Peak_mass-ref_coordinate.Peak_mass > Input_param.Tolerance_isotopic {
			return i, &query_coordinate_group
		} else if math.Abs(query_spectrum.Peaks[i].Peak_mass-ref_coordinate.Peak_mass) <= Input_param.Tolerance_isotopic {
			match_isotope_peak := &PeakElement{query_spectrum.Peaks[i].Peak_mass - ref_coordinate.Peak_mass, query_spectrum.Peaks[i].Peak_intensity, weight_intensity[i]}
			query_coordinate_group.Coordinategroup.Append(match_isotope_peak)
		}
	}
	return len(query_spectrum.Peaks), &query_coordinate_group
}

func query_coordinate_PPm(start_index int, query_spectrum reader.Spectrum, ref_coordinate reader.Signal, weight_intensity []float64, Input_param dataframe.Parameters) (int, *Coordinatelist) {
	var query_coordinate_group Coordinatelist
	query_coordinate_group.Headcoordinate.x, query_coordinate_group.Headcoordinate.y = 0.0, ref_coordinate.Peak_intensity
	for i := start_index; i < len(query_spectrum.Peaks); i++ {
		if plug.PPm(query_spectrum.Peaks[i].Peak_mass, ref_coordinate.Peak_mass) > Input_param.Tolerance_isotopic {
			return i, &query_coordinate_group
		} else if plug.PPm(query_spectrum.Peaks[i].Peak_mass, ref_coordinate.Peak_mass) <= Input_param.Tolerance_isotopic {
			match_isotope_peak := &PeakElement{query_spectrum.Peaks[i].Peak_mass - ref_coordinate.Peak_mass, query_spectrum.Peaks[i].Peak_intensity, weight_intensity[i]}
			query_coordinate_group.Coordinategroup.Append(match_isotope_peak)
		}
	}
	return len(query_spectrum.Peaks), &query_coordinate_group
}

func maprate(query_coordinate_list dataframe.LinkList, match_result *dataframe.Grade) {
	var match_counts int
	for i := 0; i < query_coordinate_list.GetLength(); i++ {
		if query_coordinate_list.Search(i).(*Coordinatelist).Coordinategroup.GetLength() != 0 {
			match_counts++
		}
	}
	match_result.TSNR = float64(match_counts) / float64(query_coordinate_list.GetLength())
}

func noiserate(query_signal_counts int, query_coordinate_list dataframe.LinkList, match_result *dataframe.Grade) {
	var match_counts int
	for i := 0; i < query_coordinate_list.GetLength(); i++ {
		match_counts = match_counts + query_coordinate_list.Search(i).(*Coordinatelist).Coordinategroup.GetLength()
	}
	match_result.ESNR = float64(match_counts) / float64(query_signal_counts)
}

func adotproduct(query_coordinate_list dataframe.LinkList, match_result *dataframe.Grade, reference_spectrum reader.Spectrum, mmi int) {
	if query_coordinate_list.GetLength() >= mmi {
		var xy, xs, ys float64
		for i := 0; i < query_coordinate_list.GetLength(); i++ {
			var maxy float64
			gemp_coordinatelist := query_coordinate_list.Search(i).(*Coordinatelist)
			if gemp_coordinatelist.Coordinategroup.GetLength() != 0 {
				var sum_dot float64
				for j := 0; j < gemp_coordinatelist.Coordinategroup.GetLength(); j++ {
					sum_dot = sum_dot + gemp_coordinatelist.Coordinategroup.Search(j).(*PeakElement).weights*gemp_coordinatelist.Headcoordinate.y*gemp_coordinatelist.Coordinategroup.Search(j).(*PeakElement).y*(1/(0.001+math.Abs(gemp_coordinatelist.Coordinategroup.Search(j).(*PeakElement).x)))
					if gemp_coordinatelist.Coordinategroup.Search(j).(*PeakElement).y >= maxy {
						maxy = gemp_coordinatelist.Coordinategroup.Search(j).(*PeakElement).y
					}
				}
				match_result.Dot_product = match_result.Dot_product + sum_dot/float64(gemp_coordinatelist.Coordinategroup.GetLength())
				xy = xy + gemp_coordinatelist.Headcoordinate.y*maxy
				xs = xs + math.Pow(gemp_coordinatelist.Headcoordinate.y, 2.0)
				ys = ys + math.Pow(maxy, 2.0)
			} else {
				match_result.Dot_product = match_result.Dot_product + 0.0
			}
		}
		if xy != 0.0 {
			match_result.Cosine_similar = xy / (math.Sqrt(xs) * math.Sqrt(ys))
		} else {
			match_result.Cosine_similar = 0
		}
	} else {
		match_result.Cosine_similar = 0
		match_result.Dot_product = 0
	}
}

func finalscore(match_result *dataframe.Grade) {
	match_result.Score = math.Pow(match_result.ESNR, 0.88) * (match_result.Dot_product * math.Pow(match_result.TSNR, 0.58))
}
